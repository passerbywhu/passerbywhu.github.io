[{"title":"Gradle基础概念","date":"2017-03-03T03:26:54.000Z","path":"2017/03/03/Gradle基础概念/","text":"自动化构建工具的演进Ant示例1234567891011121314151617181920212223242526&lt;project name=&quot;my-app&quot; default=&quot;dist&quot; basedir=&quot;.&quot;&gt; &lt;property name=&quot;src&quot; location=&quot;src&quot; /&gt; //全局属性，例如源代码、输出和发布目录 &lt;property name=&quot;build&quot; location=&quot;build&quot; /&gt; &lt;property name=&quot;dist&quot; location=&quot;dist&quot; /&gt; &lt;property name=&quot;version&quot; value=&quot;1.0&quot; /&gt; &lt;target name=&quot;init&quot;&gt; //创建由编译target使用的构建目录结构 &lt;mkdir dir=&quot;$&#123;build&#125;&quot; /&gt; &lt;/target&gt; &lt;target name=&quot;compile&quot; depends=&quot;init&quot; description=&quot;compile the source&quot;&gt; &lt;javac srcdir=&quot;$&#123;src&#125;&quot; destdir=&quot;$&#123;build&#125;&quot; //从src目录编译源代码到build目录 classpath=&quot;lib/commons-lang3-3.1.jar&quot; includeantruntime=&quot;false&quot; /&gt; &lt;target name=&quot;dist&quot; depends=&quot;compile&quot; description=&quot;generate the distribution&quot;&gt; &lt;mkdir dir=&quot;$&#123;dist&#125;:/&gt; //创建发布目录 &lt;jar jarfile=&quot;$&#123;dist&#125;/my-app-$&#123;version&#125;.jar&quot; basedir=&quot;$&#123;build&#125;&quot;/&gt; //生成jar文件 &lt;/target&gt; &lt;target name=&quot;clean&quot; description=&quot;clean up&quot;&gt; //删除build和dist目录树 &lt;delete dir=&quot;$&#123;build&#125;&quot; /&gt; &lt;delete dir=&quot;$&#123;dist&#125;&quot; /&gt; &lt;/target&gt;&lt;/project&gt; 优点 自由灵活，对于构建的结构没有强加任何限制 可以用Java语言编写自己的task扩展脚本功能缺点 XML作为构建逻辑的定义语言过于臃肿 对复杂的构建逻辑支持不好。如if-then/if-then-else build文件如何编写没有任何规范和约定，每个build文件可能都不一样。开发人员需要完整理解构建中的每个细节 Ant没有暴露API能够了解当前构建过程的详细信息 没有继承依赖管理系统。必须和Ivy配合使用 Maven示例12345678910111213141516171819&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0&quot; http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; //定义project所属的组织 &lt;artifactId&gt;my-app&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; //该project所产生的工件类型 &lt;version&gt;1.0&lt;/version&gt; //版本号影响工件的名字 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; //依赖Apache Commons Lang 3.1版本 &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; //依赖用于编译阶段 &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 优点 引入了默认的标准化项目布局 引入构建生命周期的思想 内置了依赖管理缺点 默认的结构和生命周期过于限制，不一定适合项目需求 扩展过于困难。需要学习Maven的内部扩展API。座右铭要么我的方式，要么复杂的方式 Gradle特点（结合了Maven与Ant） 具有表达性、声明式、可维护的构建语言。基于Groovy的领域特定语言（DSL），而不是XML 标准化的项目布局和生命周期，但是具有完全的灵活性和对默认值的完全可配置性 拥有易用且灵活的方式去实现定制逻辑 支持构建由多个项目的项目结构 支持依赖管理 能很好的继承和迁移现有的构建基础设施，能够引入Ant构建脚本和可以将现有的Ant和Maven逻辑转换成其自身规则集 强调可扩展性和高效率的构建座右铭让不可能成为可能，让可能变得简单，让简单变得优雅 ThoughtWorks一个软件开发咨询公司，会周期性地发布关于新技术、语言和工具的报告，帮助软件行业的决策者理解发展趋势和他们对市场的影响。在2013年5月出版的报告中，Gradle被标记为采纳状态，说明这项技术应该被行业采纳。 Gradle简介Gradle Wrapper 能够让机器在没有安装Gradle运行时的环境下运行Gradle构建 保证当前工程所有开发者的构建环境是一致的 构建工具能够被纳入版本控制系统AdvancedGradleWrapper12345wrapper &#123; gradleVersion = &apos;2.14.1&apos;&#125;$ ./gradlew tasks 参数 -P 1gradle -Pname=&quot;value&quot; taskName gradle.properties ext块 123 ext &#123; //project.ext(for extra properties) name = &quot;value&quot;&#125; rootProject.ext //在top-level build file中ext块定义的属性 Groovy一些特性 字符串中表达式 123def foo = &quot;a string&quot;println &quot;Let&apos;s do some math. 5 + 6 = $&#123;5 + 6&#125;&quot;println &quot;foo is now of type: $&#123;foo.class&#125; and has value: $foo&quot; 省略括号及返回值 函数至少有一个参数且无二义性则可以省略括号 函数最后一个表达式就是返回值 类的private属性可以通过点号访问，Groovy会自动调用生成的getter和setter方法 Closure 1234567891011def gg = &quot;I&apos;m gg&quot;def myClosure = &#123; println &quot;from myClosure&quot; println &quot;my value is $gg&quot;&#125;myClosure()gg = 5myClosure()def newFunc = myClosurenewFunc() Delegate 123456def greetingClosure = &#123; greeting = &quot;Setting the greeting from a closure&quot; printGreeting()&#125;greetingClosure.delegate = myGroovyGreetergreetingClosure() Task==the entire build script delegates to a projectobject, All the keywords in the Gradle DSL are properties of, or methods on,the project object== 声明一个task12345678910111213project.task(&quot;myTask&quot;)task(&quot;myTask&quot;) //代理给project对象task &quot;myTaks&quot; //有参数唯一性可以省略括号task myTask //a groovy objectmyTask.description = &quot;This is what&apos;s shown in the task list&quot;myTask.group = &quot;This is the heading for this task in the task list,&quot;/*task类最重要的属性是actions，doLast(closure)可以在actions尾部添加一个action*/myTask.doLast &#123;println &quot;Do this last&quot;&#125;myTask.doFirst &#123;println &quot;Do this first&quot;&#125; ==Instead of declaring a task and then setting its properties afterwards, we can also give the task a configuration closure when it’s declared.==1234567task myTask &#123; description &quot;Here&apos;s a task with a configuration block&quot; group &quot;Some group&quot; doLast &#123; println &quot;Here&apos;s the action&quot; + &quot;$&#123;&quot;\\n&quot; + description + &quot;\\n&quot; + group&#125;&quot; &#125;&#125; here are two important things to know to understand this configurationclosure. The first is that when this closure is evaluated, its delegate is thetask object. That means when you’re assigning to group, you’re reallyassigning to task.group. The second thing is that the properties of the taskobject are decorated with setters with the same names. That’s how we can omitequals signs when we’re to assigning to properties. We’re really calling asetter and leaving off the parentheses. The only gotcha is that you must include the equals sign or parentheses whenassigning a collection to a property. myTask后面跟着的closure是代理给task的。 task的对象的属性会被和属性同名的方法装饰，所以可以省略=号 集合赋给某个属性时，不能省略=号以及括号 AST Default Task设置 默认的default task是help 设置default tasks defaultTasks ‘clean’, ‘assembleDebug’ //top-level build.gradle file DAG依赖 Directed Acyclic GraphTo simplify the build process, the build tools create a dynamic model of the workflow as a Directed Acyclic Graph (DAG). dependsOn 执行该task之前，所依赖的task会执行一遍 finallizedBy 执行完该task之后，所尾随的task会执行一遍 mustRunAfter 如果和其他task共同执行，那么必须在指定task的后面才能执行 生命周期A Gradle build has three phases: Initialization: This is where the Project instance is created. If there are multiple modules, each with their own build.gradle file, multiple projects will be created. Configuration: In this phase, the build scripts are executed, creating and configuring all the tasks for every project object. Execution: This is the phase where Gradle determines which tasks should be executed. Which tasks should be executed depends on the arguments passed for starting the build and what the current directory is. 1234567task test &#123; doLast &#123; println &quot;1: I&apos;m in ur action&quot; &#125; println &quot;2: I&apos;m in ur configuration closure&quot;&#125;println &quot;3: I&apos;m in ur build script&quot; 2: I’m in ur configuration closure 3: I’m in ur build script 1: I’m in ur action==如果将println 3 移到最上面，则输出变成3,2,1==即从上往下的顺序执行，如果是语句则直接执行，如果是task则只执行Congifuration部分。最后执行task的action部分。 增量构建tasks that are marked UP-TO-DATE are skipped by Gradle because it has beendetermined that no work needed to be done. 内置Task的一些使用示例 copy 12345678910111213task copyImageFolders(type: Copy) &#123; from(&apos;images&apos;) &#123; include &apos;*.jpg&apos; into &apos;jpeg&apos; // build/jpeg &#125; from(&apos;images&apos;) &#123; include &apos;*.gif&apos; into &apos;gif&apos; // build/gif &#125; into &apos;build&apos;&#125; 压缩 1234567891011121314task zipImageFolders(type: Zip) &#123; baseName = &apos;images&apos; destinationDir = file(&apos;build&apos;) from(&apos;images&apos;) &#123; include &apos;*.jpg&apos; into &apos;jpeg&apos; &#125; from(&apos;images&apos;) &#123; include &apos;*.gif&apos; into &apos;gif&apos; &#125;&#125; 解压缩 HINT:https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:zipTree(java.lang.Object)1234task unpackBundle(type: Copy, dependsOn: bundleWeb) &#123; from zipTree(&apos;build/web.zip&apos;) into &apos;build/exploded&apos;&#125; 自定义task类型123456789101112class HelloNameTask extends DefaultTask &#123; String firstName @TaskAction void doAction() &#123; println &quot;Hello, $firstName&quot; &#125;&#125;task helloName(type: HelloNameTask) &#123; firstName = &apos;Jeremy&apos;&#125; Dry run It is possible to do a dry run of tasks, which prints out all the steps that are executed when running a specific task. This dry run will not actually perform any of these steps, so it is a safe way to see what you can expect to happen when running a certain task. You can do a dry run by adding the parameters -m or –dry-run. Java Plugin1apply plugin: &quot;java&quot; assemble check build clean 相关文档地址 Gradle Java Quickstart guide java_plugin DSL JavExec执行java方法12345task execute(type: JavaExec) &#123; main = &quot;com.udacity.gradle.Person&quot; // We&apos;ll talk about this shortly classpath = sourceSets.main.runtimeClasspath&#125; manifest中添加属性以及 main source中添加java目录12345678910111213141516apply plugin: &apos;java&apos;jar &#123; manifest &#123; attributes &apos;Implementation-Version&apos; : &apos;1.0&apos; &#125;&#125;sourceSets &#123; main &#123; java &#123; srcDir &apos;java&apos; &#125; &#125;&#125; 具体步骤 Modify the ‘jar’ task to add a manifest attribute named‘Implementation-Version’ with a value of ‘1.0’. Configure the main source set so that it includes the ‘java’ directoryas an additional source directory. manifest中添加属性 访问jar Mainifest 发现jar的manifest属性是Manifest类型。 Manifest有attributes方法，接受map为参数 Adds content to the main attributes of the manifest. attributes - The values to add to the main attributes. The values can be any object. For evaluating the value objects their Object.toString() method is used. This is done lazily either before writing or when getEffectiveManifest() is called. main source中添加java目录 访问Source Sets 参照47.7节Working with source Sets一节 查到SourceSets是Project的属性，其类型为SourceSetContainer 12345println sourceSets.main.output.classesDirprintln sourceSets[&apos;main&apos;].output.classesDirsourceSets.all &#123; println name&#125; sourceSets.all打印出main和test 47.7.1列出了SourceSet的属性并给出了SourceSet的链接，其java属性如下 The Java source files of this source set. Contains only .java files found in the Java source directories, and excludes all other files. 可见Java是个SourceDirectorySet类型，其包含srcDir方法。 Adds the given source directory to this set. The given directory does not need to exist. Directories that do not exist are ignored. 依赖管理RepositoryPreconfigured repositoriesThree Maven repositories JCenter Maven Central local Maven repository 1234567891011121314151617181920212223repositories &#123; mavenCentral() //预置的仓库 Maven Central jcenter() //预置的仓库 JCenter （安卓默认，Maven Central的超集，支持Https） mavenLocal() //预置的仓库 local Maven Repository （本地缓存。默认目录windows是%UserProfile%\\.m2 Mac是~/.m2） maven &#123; //第三方maven仓库 url &quot;http://repo.acmecorp.com/maven2&quot; [TAG:TODO] credential &#125; ivy &#123; //第三方ivy仓库 url &quot;http://repo.acmecorp.com/repo&quot; credentials &#123; username &apos;user&apos; password &apos;secret&apos; &#125; &#125; maven &#123; //Maven本地仓库 url &quot;../repo&quot; &#125; flatDir &#123; //本地仓库 dirs &apos;aars&apos; &#125;&#125; Native libraries1234567891011app ├── AndroidManifest.xml └── jniLibs ├── armeabi │ └── nativelib.so ├── armeabi-v7a │ └── nativelib.so ├── mips │ └── nativelib.so └── x86 └── nativelib.so 依赖12345678910111213141516171819202122dependencies &#123; compile files(&apos;libs/domoarigato.jar&apos;) &#125; dependencies &#123; compile fileTree(&apos;libs&apos;) &#125;dependencies &#123; compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) &#125; dependencies &#123; compile(name:&apos;libraryname&apos;, ext:&apos;aar&apos;) &#125; dependencies &#123; compile project(&apos;:moduleName&apos;) &#125; dependencies &#123; compile &apos;com.android.support:support-v4:22.2.+&apos; //最新的patch compile &apos;com.android.support:appcompat-v7:22.2+&apos; //此版本号大于2的最新版本 compile &apos;com.android.support:recyclerview-v7:+&apos; //最新版本&#125; 查看依赖123$ gradle dependencies$ gradle dependencyInsight --dependency commons-logging Dependency conceptscompile default add to the classpath add to the generated APKapk only be added to the package not added to the compilation classpath only take JAR dependenciesprovided will not be packaged added to the compilation classpath only take JAR dependenciestestCompileandroidTestCompile extra libraries specifically for testing included in the test apk, not in the release apk Configuration In order to be able to compile the code, you need to add the SDK to your compile classpath. You do not need to include the SDK in your APK though, because it is already on the device. This is where dependency configurations come in. Gradle groups dependencies into configurations==the Android plugin also generates configurations for every build variant== 内置Configuration compile runtime testCompile exntends from ‘compile’ configuration testRuntime extends from ‘runtime’ configuration SpecificDependencies123debugCompile &apos;com.squareup.leakcanary:leakcanary-android:1.5&apos;releaseCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5&apos;androidTestCompile &apos;com.android.support.test:runner:0.4&apos; 自定义Configuration123456789configurations &#123; println &apos;configurations class is &apos; + it.class //DefaultConfigurationContainer_Decorated custom &#123; description &apos;I am a customed configuration&apos; println &apos;custom class is &apos; + it.class //DefaultConfiguration_Decorated transitive = false &#125; compile.extendsFrom custom&#125; configurations) {} This method executes the given closure against the ConfigurationContainer for this project. The ConfigurationContainer is passed to the closure as the closure’s delegate. CongifurationContainer A ==dynamic== method is added for each configuration which takes a configuration closure. ==This is equivalent to calling ConfigurationContainer.getByName(java.lang.String, groovy.lang.Closure)==. For example: 1234configurations.create(&apos;myConfiguration&apos;)configurations.myConfiguration &#123; transitive = false&#125; 12345678dependencies &#123; println &apos;dependencies class is &apos; + it.class //DefaultDependencyHandler_Decorated custom &apos;com.google.guava:guava:18.0&apos; // 这里估计custom也是动态增加的方法 custom(group:&apos;com.google.guava&apos;, name: &apos;guava&apos;, version:&apos;18.0&apos;) &#123; println &apos;custom dependency class is &apos; + it.class //DefaultExternalModuleDependency_Decorated &#125;&#125; Configurations are really just fancy file collections and can be used anywherea file collection can be used, such as in Copy tasks. This is useful if wewant to download some dependencies from a remote repository and bundle them inour project somehow. 1234task copyDependencies(type: Copy) &#123; from configurations.custom into &apos;build/libs&apos;&#125; Build Variantbuild types和product flavors的结合 假设有red和color两个productFlavor，debug和release两个build type assembleBlue 相当于执行assembleBlueRelease和assembleBlueDebug assembleDebug 相当于执行assembleBlueDebug和assembleRedDebug assembleBlueDebug flavor settings override the build type settings Build TypeBuildConfig and resources Ever since SDK tools revision 17, the build tools generate a class called BuildConfig, which contains a DEBUG constant that is set according to the build type. This is useful if you have code that you only want to run when debugging, such as logging. It is possible through Gradle to extend that file so that you can have constants that contain different values in debug and release. 12345678910111213141516android &#123; buildTypes &#123; debug &#123; buildConfigField &quot;String&quot;, &quot;API_URL&quot;, &quot;\\&quot;http://test.example.com/api\\&quot;&quot; buildConfigField &quot;boolean&quot;, &quot;LOG_HTTP_CALLS&quot;, &quot;true&quot; resValue &quot;string&quot;, &quot;app_name&quot;, &quot;Example DEBUG&quot; &#125; release &#123; buildConfigField &quot;String&quot;, &quot;API_URL&quot;, &quot;\\&quot;http://example.com/api\\&quot;&quot; //这里双引号转义是需要的 buildConfigField &quot;boolean&quot;, &quot;LOG_HTTP_CALLS&quot;, &quot;false&quot; resValue &quot;string&quot;, &quot;app_name&quot;, &quot;Example&quot; //这里不需要双引号转移是因为value=&quot;&quot;已经有双引号了 &#125; &#125;&#125; Product flavors As opposed to build types, which are used to configure several different builds of the same app or library, product flavors are used to create different versions of the same app.12345678productFlavors &#123; free &#123; applicationId &quot;com.gradle.buildflavors.free&quot; &#125; paid &#123; applicationId &quot;com.gradle.buildflavors.paid&quot; &#125;&#125; ApplicationId The first property in this block is applicationId. This overrides the package name from the manifest file, but there are some differences between applicationId and the package name. Before Gradle was used as the default Android build system, the package name in AndroidManifest.xml had two purposes: it served as the unique identifier of an app, and it was used as the name for the package in the R resource class. Android Tools team has decoupled these two different usages of package name. The package, as defined in the manifest file, continues to be used in your source code and your R class, while the package name that is used by the device and Google Play as the unique identifier is now referred to as application id. Multiflavor variants场景： A需要free和pay版本，用A的商标。B需要free和pay的版本，用B的商标。 普通的方式需要新建freeIconA, freeIconB, payIconA, payIconB四个productFlavor 123456789101112131415161718android &#123; flavorDimensions &quot;color&quot;, &quot;price&quot; //顺序决定了build variant的名字和资源覆盖的逻辑 productFlavors &#123; red &#123; flavorDimension &quot;color&quot; &#125; blue &#123; flavorDimension &quot;color&quot; &#125; free &#123; flavorDimension &quot;price&quot; &#125; paid &#123; flavorDimension &quot;price&quot; &#125; &#125; &#125; 如何在Build Type和Product Flavor中进行选择 If you are unsure whether you need a new build type, or a new product flavor, you should ask yourself if you want to create a new build of the same app for internal use, or a new APK to publish to Google Play. If you need an entirely new app that needs to be published separately from what you already have, then product flavors are the way to go. Otherwise, you should stick to using build types. SourceSets the flavor name followed by the build type name. The components of the combined folder will have a higher priority than the components from both the build type folder and the product flavor folder. 如果在某个SourceSet中定义了Java class。那么就不能在sourceSets.main中定义该类 drawables and layouts会覆盖sourceSets.main中的 values文件夹中的资源会和sourceSets.main中的合并，相同的则覆盖 manifest文件也和values一样的规则 Sign Configuration 12345678910111213141516signingConfigs &#123; config &#123; keyAlias &apos;udacity&apos; keyPassword &apos;password&apos; storeFile file(&quot;$rootDir/keystore.jks&quot;) storePassword &apos;password&apos; &#125; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), proguard-rules.pro&apos; signingConfig signingConfigs.config &#125; &#125; 爱玩示例1234567891011121314151617181920212223242526272829303132333435363738signingConfigs &#123; //gradle assembleRelease release &#123; storeFile file(&quot;android.keystore&quot;) storePassword keystorePassword keyAlias &quot;iplay_android&quot; keyPassword keystorePassword &#125; google &#123; storeFile file(&quot;google.keystore&quot;) storePassword keystorePassword keyAlias &quot;iplay_google&quot; keyPassword keystorePassword &#125; &#125; productFlavors &#123; productFlavors.all &#123; flavor -&gt; flavor.manifestPlaceholders = [CHANNEL_VALUE: name] if (flavor.name.equals(&quot;google&quot;)) &#123; flavor.signingConfig = signingConfigs.google &#125; else &#123; flavor.signingConfig = signingConfigs.release &#125; &#125;&#125;android.applicationVariants.all &#123; variant -&gt; for (flavor in variant.productFlavors) &#123; def file = variant.outputs[0].outputFile variant.outputs[0].outputFile = new File(file.parent, applicationId + &quot;-&quot; + defaultConfig.versionName + &quot;-&quot; + flavor.name + &quot;.apk&quot;); &#125; &#125; configurations &#123; all*.exclude group: &apos;com.squareup.okhttp3&apos;, module: &apos;okhttp&apos;&#125; 1234567891011121314app |--src |--main | |--res | |--drawable | |--yw_1222_0335.jpg | |--google | |--res | |--drawable | |--yw_1222_0335.jpg | |--googleDebug |--googleRelease 小技巧Changing the Android Studio terminal It is possible to configure the terminal inside Android Studio to use a different shell. On Microsoft Windows, for example, the terminal defaults to Command Prompt. If you prefer to use the Git Bash (or any other shell) instead, open the Android Studio settings (under File and Settings) and look for Terminal. There you can change the shell path. For Git Bash on Microsoft Windows, it looks like this: C:\\Program Files (x86)\\Git\\bin\\sh.exe –login -i.","tags":[]},{"title":"MarkDown测试","date":"2017-02-15T03:39:46.000Z","path":"2017/02/15/MarkDown示例/","text":"一级标题二级标题三级标题四级标题五级标题六级标题代码高亮123public static void main(String[] args) &#123; System.out.println(\"Hello World\");&#125; To-do List [x] 已完成项目1 [x] 已完成事项1 [x] 已完成事项2 [ ] 代办事项1 [ ] 代办事项2 流程图123456graph TD A[Christmas]--&gt;B(Go shopping) B--&gt;C&#123;let me think&#125; C--&gt;|One| D[Laptop] C--&gt;|Two|E[iphone] C--&gt;|Three|F[Car] 123456graph LR A[Christmas]--&gt;B(Go shopping) B--&gt;C&#123;let me think&#125; C--&gt;|One| D[Laptop] C--&gt;|Two|E[iphone] C--&gt;|Three|F[Car] 序列图123sequenceDiagramA-&gt;&gt;B: How are you?B-&gt;&gt;A: Great! 1234567sequenceDiagram loop every day Alice-&gt;&gt;John: Hello John, how are you? John-&gt;&gt;Alice: Greate! end Alice-&gt;&gt;Hank: Do it now Hank-&gt;&gt;John: You can go to find Alice now 甘特图123456789ganttdateFormat YYYY-MM-DDtitle 产品计划表section 初期阶段明确需求: 2016-03-01, 10dsection 中期阶段跟进开发: 2016-03-11, 15dsection 后期阶段走查测试: 2016-03-20, 9d 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 无序列表 列表1 列表1.1 列表1.2 列表2 列表3 有序列表 列表1 列表1.1 列表1.2 列表2 列表3 引用 记录，成为更好的自己。或许你说的是对的 粗体和斜体这是斜体这是粗体 插入链接百度 插入图片 12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d","tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://yoursite.com/tags/MarkDown/"}]}]